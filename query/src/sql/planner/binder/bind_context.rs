// Copyright 2022 Datafuse Labs.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use common_ast::ast::Identifier;
use common_ast::ast::TableAlias;
use common_ast::parser::error::DisplayError as _;
use common_datavalues::prelude::*;
use common_exception::ErrorCode;
use common_exception::Result;

use super::aggregate::AggregateInfo;
use crate::sql::common::IndexType;
use crate::sql::plans::Scalar;

#[derive(Clone, PartialEq, Debug)]
pub struct ColumnBinding {
    /// Table name of this `ColumnBinding` in current context
    pub table_name: Option<String>,
    /// Column name of this `ColumnBinding` in current context
    pub column_name: String,
    /// Column index of ColumnBinding
    pub index: IndexType,

    pub data_type: DataTypeImpl,

    /// A `ColumnBinding` is visible if it's:
    ///   - Produced by a base table. For example, `SELECT a FROM t`.
    ///   - Produced by a derived table and qualified with alias. For example,
    ///     `SELECT * FROM (SELECT a, a+1 AS b, a+2 /* invisible */ FROM t)`
    pub visible: bool,

    /// Scalar expression the `ColumnBinding` refers to(if exists).
    /// For example, a column `b` can be generated by `SELECT a+1 AS b FROM t`.
    /// Another example is aggregation. In a `GROUP BY` context, aggregate funtions
    /// will be extracted and be added to `BindContext` as a `ColumnBinding`.
    pub scalar: Option<Box<Scalar>>,
}

/// `BindContext` stores all the free variables in a query and tracks the context of binding procedure.
#[derive(Clone, Default, Debug)]
pub struct BindContext {
    _parent: Option<Box<BindContext>>,
    pub columns: Vec<ColumnBinding>,

    /// Aggregate information, is `Some` when in aggregate context, for example in `HAVING`
    pub agg_info: Option<AggregateInfo>,
}

impl BindContext {
    pub fn new() -> Self {
        Self::default()
    }

    pub fn with_parent(parent: Box<BindContext>) -> Self {
        BindContext {
            _parent: Some(parent),
            columns: vec![],
            agg_info: None,
        }
    }

    /// Generate a new BindContext and take current BindContext as its parent.
    pub fn push(self) -> Self {
        Self::with_parent(Box::new(self))
    }

    /// Returns all column bindings in current scope.
    pub fn all_column_bindings(&self) -> &[ColumnBinding] {
        &self.columns
    }

    pub fn add_column_binding(&mut self, column_binding: ColumnBinding) {
        self.columns.push(column_binding);
    }

    /// Apply table alias like `SELECT * FROM t AS t1(a, b, c)`.
    /// This method will rename column bindings according to table alias.
    pub fn apply_table_alias(&mut self, alias: &TableAlias) -> Result<()> {
        for column in self.columns.iter_mut() {
            column.table_name = Some(alias.name.to_string());
        }

        if alias.columns.len() > self.columns.len() {
            return Err(ErrorCode::SemanticError(format!(
                "table has {} columns available but {} columns specified",
                self.columns.len(),
                alias.columns.len()
            )));
        }
        for (index, column_name) in alias.columns.iter().map(ToString::to_string).enumerate() {
            self.columns[index].column_name = column_name;
        }
        Ok(())
    }

    /// Try to find a column binding with given table name and column name.
    /// This method will return error if the given names are ambiguous or invalid.
    pub fn resolve_column(
        &self,
        table: Option<String>,
        column: &Identifier,
    ) -> Result<ColumnBinding> {
        // TODO: lookup parent context to support correlated subquery
        let mut result = vec![];
        if let Some(table) = table {
            for column_binding in self.columns.iter() {
                if let Some(table_name) = &column_binding.table_name {
                    if table_name == &table
                        && column_binding.column_name == column.name
                        && column_binding.visible
                    {
                        result.push(column_binding.clone());
                    }
                }
            }
        } else {
            for column_binding in self.columns.iter() {
                if column_binding.column_name == column.name && column_binding.visible {
                    result.push(column_binding.clone());
                }
            }
        }

        if result.is_empty() {
            Err(ErrorCode::SemanticError(
                column
                    .span
                    .display_error("column doesn't exist".to_string()),
            ))
        } else if result.len() > 1 {
            Err(ErrorCode::SemanticError(
                column
                    .span
                    .display_error("column reference is ambiguous".to_string()),
            ))
        } else {
            Ok(result.remove(0))
        }
    }

    /// Get result columns of current context in order.
    /// For example, a query `SELECT b, a AS b FROM t` has `[(index_of(b), "b"), index_of(a), "b"]` as
    /// its result columns.
    ///
    /// This method is used to retrieve the physical representation of result set of
    /// a query.
    pub fn result_columns(&self) -> Vec<(IndexType, String)> {
        self.columns
            .iter()
            .map(|col| (col.index, col.column_name.clone()))
            .collect()
    }

    /// Return true if in aggregate context. Only group items and aggregate
    /// functions can be accessed in such a context.
    pub fn in_group_context(&self) -> bool {
        self.agg_info.is_some()
    }
}
